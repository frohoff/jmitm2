/*
 *  Sshtools - Java SSH2 API
 *
 *  Copyright (C) 2002 Lee David Painter.
 *
 *  Written by: 2002 Lee David Painter <lee@sshtools.com>
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public License
 *  as published by the Free Software Foundation; either version 2 of
 *  the License, or (at your option) any later version.
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Library General Public
 *  License along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package com.sshtools.j2ssh.transport;

import java.io.IOException;

import java.util.Random;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;

import com.sshtools.j2ssh.configuration.SshConnectionProperties;
import com.sshtools.j2ssh.transport.cipher.SshCipherFactory;
import com.sshtools.j2ssh.transport.compression.SshCompressionFactory;
import com.sshtools.j2ssh.transport.hmac.SshHmacFactory;
import com.sshtools.j2ssh.transport.kex.SshKeyExchangeFactory;
import com.sshtools.j2ssh.transport.publickey.SshKeyPairFactory;
import com.sshtools.j2ssh.io.ByteArrayReader;
import com.sshtools.j2ssh.io.ByteArrayWriter;

import com.sshtools.j2ssh.configuration.ConfigurationLoader;

/**
 *  <p>
 *
 *  This class implements the Key exchange init message. Key exchange begins by
 *  each side sending the following packet: </p> <b>byte SSH_MSG_KEXINIT<br>
 *  byte[16] cookie (random bytes)<br>
 *  string kex_algorithms<br>
 *  string server_host_key_algorithms<br>
 *  string encryption_algorithms_client_to_server<br>
 *  string encryption_algorithms_server_to_client<br>
 *  string mac_algorithms_client_to_server<br>
 *  string mac_algorithms_server_to_client<br>
 *  string compression_algorithms_client_to_server<br>
 *  string compression_algorithms_server_to_client<br>
 *  string languages_client_to_server<br>
 *  string languages_server_to_client<br>
 *  boolean first_kex_packet_follows<br>
 *  uint32 0 (reserved for future extension) </b> <p>
 *
 *  Each of the algorithm strings MUST be a comma-separated list of algorithm
 *  names (see ''Algorithm Naming'' in [SSH-ARCH]). Each supported (allowed)
 *  algorithm MUST be listed in order of preference. </p> <p>
 *
 *  The first algorithm in each list MUST be the preferred (guessed) algorithm.
 *  Each string MUST contain at least one algorithm name. </p> <p>
 *
 *  cookie<br>
 *  The cookie MUST be a random value generated by the sender. Its purpose is to
 *  make it impossible for either side to fully determine the keys and the
 *  session identifier. </p> <p>
 *
 *  kex_algorithms<br>
 *  Key exchange algorithms were defined above. The first algorithm MUST be the
 *  preferred (and guessed) algorithm. If both sides make the same guess, that
 *  algorithm MUST be used. Otherwise, the following algorithm MUST be used to
 *  choose a key exchange method: iterate over client's kex algorithms, one at a
 *  time. Choose the first algorithm that satisfies the following conditions:
 *  <br>
 *  + the server also supports the algorithm,<br>
 *  + if the algorithm requires an encryption-capable host key, there is an
 *  encryption-capable algorithm on the server's server_host_key_algorithms that
 *  is also supported by the client, and<br>
 *  + if the algorithm requires a signature-capable host key, there is a
 *  signature-capable algorithm on the server's server_host_key_algorithms that
 *  is also supported by the client.<br>
 *  + If no algorithm satisfying all these conditions can be found, the
 *  connection fails, and both sides MUST disconnect. </p> <p>
 *
 *  server_host_key_algorithms<br>
 *  List of the algorithms supported for the server host key. The server lists
 *  the algorithms for which it has host keys; the client lists the algorithms
 *  that it is willing to accept. (There MAY be multiple host keys for a host,
 *  possibly with different algorithms.) </p> <p>
 *
 *  Some host keys may not support both signatures and encryption (this can be
 *  determined from the algorithm), and thus not all host keys are valid for all
 *  key exchange methods. </p> <p>
 *
 *  Algorithm selection depends on whether the chosen key exchange algorithm
 *  requires a signature or encryption capable host key. It MUST be possible to
 *  determine this from the public key algorithm name. The first algorithm on
 *  the client's list that satisfies the requirements and is also supported by
 *  the server MUST be chosen. If there is no such algorithm, both sides MUST
 *  disconnect. </p> <p>
 *
 *  encryption_algorithms<br>
 *  Lists the acceptable symmetric encryption algorithms in order of preference.
 *  The chosen encryption algorithm to each direction MUST be the first
 *  algorithm on the client's list that is also on the server's list. If there
 *  is no such algorithm, both sides MUST disconnect. </p> <p>
 *
 *  Note that "none" must be explicitly listed if it is to be acceptable. The
 *  defined algorithm names are listed in Section Section 4.3. </p> <p>
 *
 *  mac_algorithms<br>
 *  Lists the acceptable MAC algorithms in order of preference. The chosen MAC
 *  algorithm MUST be the first algorithm on the client's list that is also on
 *  the server's list. If there is no such algorithm, both sides MUST
 *  disconnect. </p> <p>
 *
 *  Note that "none" must be explicitly listed if it is to be acceptable. The
 *  MAC algorithm names are listed in Section Figure 1. </p> <p>
 *
 *  compression_algorithms<br>
 *  Lists the acceptable compression algorithms in order of preference. The
 *  chosen compression algorithm MUST be the first algorithm on the client's
 *  list that is also on the server's list. If there is no such algorithm, both
 *  sides MUST disconnect. </p> <p>
 *
 *  Note that "none" must be explicitly listed if it is to be acceptable. The
 *  compression algorithm names are listed in Section Section 4.2. </p> <p>
 *
 *  languages<br>
 *  This is a comma-separated list of language tags in order of preference
 *  [RFC1766]. Both parties MAY ignore this list. If there are no language
 *  preferences, this list SHOULD be empty. </p> <p>
 *
 *  first_kex_packet_follows<br>
 *  Indicates whether a guessed key exchange packet follows. If a guessed packet
 *  will be sent, this MUST be TRUE. If no guessed packet will be sent, this
 *  MUST be FALSE. </p> <p>
 *
 *  After receiving the SSH_MSG_KEXINIT packet from the other side, each party
 *  will know whether their guess was right. If the other party's guess was
 *  wrong, and this field was TRUE, the next packet MUST be silently ignored,
 *  and both sides MUST then act as determined by the negotiated key exchange
 *  method. If the guess was right, key exchange MUST continue using the guessed
 *  packet. </p> <p>
 *
 *  After the KEXINIT packet exchange, the key exchange algorithm is run. It may
 *  involve several packet exchanges, as specified by the key exchange method.
 *  </p>
 *
 *@author     <A HREF="mailto:lee@sshtools.com">Lee David Painter</A>
 *@created    31 August 2002
 *@version    $Id: SshMsgKexInit.java,v 1.11 2003/02/05 14:39:52 martianx Exp $
 */
class SshMsgKexInit
         extends SshMessage {
    /**
     *  The message id for this message
     */
    protected final static int SSH_MSG_KEX_INIT = 20;
    private List supportedCompCS;
    private List supportedCompSC;
    private List supportedEncryptCS;
    private List supportedEncryptSC;
    private List supportedKex;
    private List supportedLangCS;
    private List supportedLangSC;
    private List supportedMacCS;
    private List supportedMacSC;
    private List supportedPK;

    // Message values
    private byte cookie[];
    private boolean firstKexFollows;


    /**
     *  Default constructor
     */
    public SshMsgKexInit() {
        super(SSH_MSG_KEX_INIT);
    }


    /**
     *  Constructs the message for sending from the required connection
     *  properties
     *
     *@param  props  The connection properties
     */
    public SshMsgKexInit(SshConnectionProperties props) {
        super(SSH_MSG_KEX_INIT);

        // Create some random data
        cookie = new byte[16];

        // Seed the random number generator
        Random r = ConfigurationLoader.getRND();

        // Get the next random bytes into our cookie
        r.nextBytes(cookie);

        // Get the supported algorithms from the factory objects but adding the
        // preffered algorithm to the top of the list
        supportedKex =
                sortAlgorithmList(SshKeyExchangeFactory.getSupportedKeyExchanges(),
                props.getPrefKex());

        supportedPK =
                sortAlgorithmList(SshKeyPairFactory.getSupportedKeys(),
                props.getPrefPublicKey());

        supportedEncryptCS =
                sortAlgorithmList(SshCipherFactory.getSupportedCiphers(),
                props.getPrefCSEncryption());

        supportedEncryptSC =
                sortAlgorithmList(SshCipherFactory.getSupportedCiphers(),
                props.getPrefSCEncryption());

        supportedMacCS =
                sortAlgorithmList(SshHmacFactory.getSupportedMacs(),
                props.getPrefCSMac());

        supportedMacSC =
                sortAlgorithmList(SshHmacFactory.getSupportedMacs(),
                props.getPrefSCMac());

        supportedCompCS =
                sortAlgorithmList(SshCompressionFactory.getSupportedCompression(),
                props.getPrefCSComp());

        supportedCompSC =
                sortAlgorithmList(SshCompressionFactory.getSupportedCompression(),
                props.getPrefSCComp());

        // We currently don't support language preferences
        supportedLangCS = new ArrayList();
        supportedLangSC = new ArrayList();

        // We don't guess (I don't see the point of this in the protocol!)
        firstKexFollows = false;
    }


    /**
     *  Gets the message name for debugging
     *
     *@return    "SSH_MSG_KEX_INIT"
     */
    public String getMessageName() {
        return "SSH_MSG_KEX_INIT";
    }


    /**
     *  Gets the supported compression algorithms for client->server
     *
     *@return    The supported compression algorithms
     */
    public List getSupportedCSComp() {
        return supportedCompCS;
    }


    /**
     *  Gets the supported encryption algorithms for client->server
     *
     *@return    The list of supported algorithms
     */
    public List getSupportedCSEncryption() {
        return supportedEncryptCS;
    }


    /**
     *  Gets the supported message authentication algorithms for client->server
     *
     *@return    The supported message authentication algorithms
     */
    public List getSupportedCSMac() {
        return supportedMacCS;
    }


    /**
     *  Gets the supported key exchanges
     *
     *@return    The list of key exchanges
     */
    public List getSupportedKex() {
        return supportedKex;
    }


    /**
     *  Sets the supported public key algortihms
     *
     *@param  pks  a list of public key algorithm strings
     */
    public void setSupportedPK(List pks) {
        supportedPK.clear();
        supportedPK.addAll(pks);
        sortAlgorithmList(supportedPK, SshKeyPairFactory.getDefaultPublicKey());
    }


    /**
     *  Gets the supported public keys algorithms
     *
     *@return    The supported public key algorithms
     */
    public List getSupportedPublicKeys() {
        return supportedPK;
    }


    /**
     *  Gets the supported compression algorithms for server->client
     *
     *@return    The supported compression algorithms
     */
    public List getSupportedSCComp() {
        return supportedCompSC;
    }


    /**
     *  Gets the supported encryption algorithms for server->client
     *
     *@return    The list of supported algorithms
     */
    public List getSupportedSCEncryption() {
        return supportedEncryptSC;
    }


    /**
     *  Gets the supported message authentication algorithms for server->client
     *
     *@return    The supported message authentication algorithms
     */
    public List getSupportedSCMac() {
        return supportedMacSC;
    }


    /**
     *  Creates a delimited string from a list.
     *
     *@param  list  The list object.
     *@return       The string containing a comma delimited list.
     */
    public String createDelimString(List list) {
        // Set up the seperator (blank to start cause we dont want a comma
        // at the beginning of the list)
        String sep = "";
        String ret = "";

        // Iterate through the list
        Iterator it = list.iterator();

        while (it.hasNext()) {
            // Add the seperator and then the item
            ret += (sep + (String) it.next());

            sep = ",";
        }

        return ret;
    }


    /**
     *  Returns a string representation of the message (for debugging).
     *
     *@return    The string representation of the message.
     */
    public String toString() {
        String ret = "SshMsgKexInit:\n";
        ret += ("Supported Kex " + supportedKex.toString() + "\n");
        ret += ("Supported Public Keys " + supportedPK.toString() + "\n");
        ret += ("Supported Encryption Client->Server "
                + supportedEncryptCS.toString() + "\n");
        ret += ("Supported Encryption Server->Client "
                + supportedEncryptSC.toString() + "\n");
        ret += ("Supported Mac Client->Server " + supportedMacCS.toString()
                + "\n");
        ret += ("Supported Mac Server->Client " + supportedMacSC.toString()
                + "\n");
        ret += ("Supported Compression Client->Server "
                + supportedCompCS.toString() + "\n");
        ret += ("Supported Compression Server->Client "
                + supportedCompSC.toString() + "\n");
        ret += ("Supported Languages Client->Server "
                + supportedLangCS.toString() + "\n");
        ret += ("Supported Languages Server->Client "
                + supportedLangSC.toString() + "\n");
        ret += ("First Kex Packet Follows ["
                + (firstKexFollows ? "TRUE]" : "FALSE]"));

        return ret;
    }


    /**
     *  Abstract method implementation to construct a byte array for sending the
     *  data.
     *
     *@param  baw                          The byte array being written to.
     *@exception  InvalidMessageException  if the message is invalid
     */
    protected void constructByteArray(ByteArrayWriter baw)
             throws InvalidMessageException {
        try {
            baw.write(cookie);

            baw.writeString(createDelimString(supportedKex));
            baw.writeString(createDelimString(supportedPK));
            baw.writeString(createDelimString(supportedEncryptCS));
            baw.writeString(createDelimString(supportedEncryptSC));
            baw.writeString(createDelimString(supportedMacCS));
            baw.writeString(createDelimString(supportedMacSC));
            baw.writeString(createDelimString(supportedCompCS));
            baw.writeString(createDelimString(supportedCompSC));
            baw.writeString(createDelimString(supportedLangCS));
            baw.writeString(createDelimString(supportedLangSC));
            baw.write((firstKexFollows ? 1 : 0));
            baw.writeInt(0);
        } catch (IOException ioe) {
            throw new InvalidMessageException("Error writing message data: "
                    + ioe.getMessage());
        }
    }


    /**
     *  Abstract method implementation to constrcut the message from a byte
     *  array.
     *
     *@param  bar                          The byte array being read.
     *@exception  InvalidMessageException  if the message is invalid
     */
    protected void constructMessage(ByteArrayReader bar)
             throws InvalidMessageException {
        try {
            cookie = new byte[16];
            bar.read(cookie);

            supportedKex = loadListFromString(bar.readString());
            supportedPK = loadListFromString(bar.readString());
            supportedEncryptCS = loadListFromString(bar.readString());
            supportedEncryptSC = loadListFromString(bar.readString());
            supportedMacCS = loadListFromString(bar.readString());
            supportedMacSC = loadListFromString(bar.readString());
            supportedCompCS = loadListFromString(bar.readString());
            supportedCompSC = loadListFromString(bar.readString());
            supportedLangCS = loadListFromString(bar.readString());

            supportedLangSC = loadListFromString(bar.readString());

            firstKexFollows = (bar.read() == 0) ? false : true;
        } catch (IOException ioe) {
            throw new InvalidMessageException("Error reading message data: "
                    + ioe.getMessage());
        }
    }


    /**
     *  Loads a list object from a comma delimeted string.
     *
     *@param  str  The string containing the list.
     *@return      The constrcuted list.
     */
    private List loadListFromString(String str) {
        // Create a tokeizer object
        StringTokenizer tok = new StringTokenizer(str, ",");

        List ret = new ArrayList();

        // Iterate through the tokens adding the items to the list
        while (tok.hasMoreElements()) {
            ret.add(tok.nextElement());
        }

        return ret;
    }


    /**
     *  Sorts the provided list by moving the prefered to the top of the list.
     *
     *@param  list  The list to sort.
     *@param  pref  The item to add to the top of the list.
     *@return       The sorted list.
     */
    private List sortAlgorithmList(List list, String pref) {
        if (list.contains(pref)) {
            // Remove the prefered from the list wherever it may be
            list.remove(pref);

            // Add it to the beginning of the list
            list.add(0, pref);
        }

        return list;
    }
}
